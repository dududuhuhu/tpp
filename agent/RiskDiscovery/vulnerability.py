import pymysql
import requests
import requests
import json
import time
from datetime import datetime
from typing import List, Dict, Optional


class DoRequest:
    """
    专门用于发起请求的类： GET/POST
    """
    def __init__(self, path: str, method: str, data: str, timeout: int = 10):
        # 请求的路径
        self.__path = path
        # 请求的方法
        self.__method = method.upper()
        # 请求的数据
        self.__data = data
        # 超时时间
        self.__timeout = timeout
    def do_request(self) -> Optional[str]:
        """
        发起请求的方法
        :return: 响应内容或None
        """
        if self.__method == 'GET':
            return self.__do_get()
        elif self.__method == 'POST':
            return self.__do_post()
        else:
            print(f"不支持的请求方法: {self.__method}")
            return None

    def __do_get(self) -> Optional[str]:
        """
        发起GET请求的方法
        :return: 响应内容或None
        """
        try:
            # 准备请求的URL地址
            url = self.__path + self.__data
            print(f"发起GET请求: {url}")

            # 设置请求头
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }

            # 发起请求
            response = requests.get(url, headers=headers, timeout=self.__timeout)

            # 获取响应结果并解码
            result = response.content.decode('utf-8', errors='ignore')
            return result

        except requests.exceptions.Timeout:
            print(f"请求超时: {self.__path}")
            return None
        except requests.exceptions.ConnectionError:
            print(f"连接错误: {self.__path}")
            return None
        except Exception as e:
            print(f"GET请求异常: {e}")
            return None

    def __do_post(self) -> Optional[str]:
        """
        发起POST请求的方法
        :return: 响应内容或None
        """
        try:
            # 设置请求头
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Content-Type': 'application/x-www-form-urlencoded'
            }

            print(f"发起POST请求: {self.__path}")

            # 发起请求
            response = requests.post(
                url=self.__path,
                data=self.__data,
                headers=headers,
                timeout=self.__timeout
            )

            # 获取响应结果并解码
            result = response.content.decode('utf-8', errors='ignore')
            return result

        except requests.exceptions.Timeout:
            print(f"请求超时: {self.__path}")
            return None
        except requests.exceptions.ConnectionError:
            print(f"连接错误: {self.__path}")
            return None
        except Exception as e:
            print(f"POST请求异常: {e}")
            return None


class VulnerabilityScanner:
    """
    漏洞扫描器类
    """

    def __init__(self):
        # self.java_platform_url = java_platform_url
        self.scan_results = []


    def _get_sample_rules(self) -> List[Dict]:
        """
        获取示例漏洞规则（用于测试）
        :return: 示例漏洞规则列表
        """
        #         """从数据库中获取漏洞规则"""
        #         # sql = "SELECT vul_name, vul_request_type, vul_path, vul_payload, vul_flag FROM vulnerability"
        #         # self.cursor.execute(sql)
        #         # return self.cursor.fetchall()

        return [
            {
                'id': 1,
                'vul_name': '本地SQL注入测试漏洞',
                'vul_desc': 'SQL注入：id参数未过滤',
                'vul_level': 1,
                'vul_request_type': 'GET',
                'vul_type': 'SQL注入',
                'vul_path': 'http://127.0.0.1:8080',
                'vul_payload': "?id=1' OR 1=1-- ",
                'vul_flag': 'Welcome admin'
            }
        ]

    def scan_vulnerability(self, rule: Dict) -> Dict:
        """
        扫描单个漏洞
        :param rule: 漏洞规则
        :return: 扫描结果
        """
        print(f"\n正在扫描漏洞: {rule['vul_name']}")

        # 创建请求对象
        request_obj = DoRequest(
            path=rule['vul_path'],
            method=rule['vul_request_type'],
            data=rule['vul_payload']
        )

        # 发起请求
        start_time = time.time()
        response_content = request_obj.do_request()
        end_time = time.time()

        # 分析结果
        scan_result = {
            'rule_id': rule.get('id'),
            'vul_name': rule['vul_name'],
            'vul_type': rule['vul_type'],
            'vul_level': rule['vul_level'],
            'target_url': rule['vul_path'],
            'payload': rule['vul_payload'],
            'scan_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'response_time': round(end_time - start_time, 2),
            'is_vulnerable': False,
            'response_content': response_content or '',
            'error_message': ''
        }

        if response_content:
            # 检查是否存在漏洞标识
            if rule['vul_flag'] in response_content:
                scan_result['is_vulnerable'] = True
                scan_result['vulnerability_confirmed'] = True
                print(f"✓ 发现漏洞: {rule['vul_name']}")
            else:
                print(f"✗ 未发现漏洞: {rule['vul_name']}")
        else:
            scan_result['error_message'] = '请求失败，无法获取响应'
            print(f"✗ 扫描失败: {rule['vul_name']}")

        return scan_result

    def batch_scan(self, rules: List[Dict]) -> List[Dict]:
        """
        批量扫描漏洞
        :param rules: 漏洞规则列表
        :return: 扫描结果列表
        """
        print(f"\n开始批量扫描，共 {len(rules)} 个漏洞规则")
        results = []

        for i, rule in enumerate(rules, 1):
            print(f"\n[{i}/{len(rules)}] ", end='')
            result = self.scan_vulnerability(rule)
            if result['is_vulnerable']:
                results.append(result)

            # 添加延时避免过于频繁的请求
            time.sleep(0.5)

        return results


    def run_scan(self):
        """
        运行完整的扫描流程
        """
        print("=== 漏洞扫描器启动 ===")

        # 1. 获取漏洞规则
        rules = self._get_sample_rules()
        if not rules:
            print("未获取到漏洞规则，扫描终止")
            return

        # 2. 执行批量扫描
        results = self.batch_scan(rules)

        return results


# 使用示例
if __name__ == "__main__":

    # 创建扫描器实例
    scanner = VulnerabilityScanner()
    # 运行扫描，返回结果
    scan_results = scanner.run_scan()
    print(f"\n扫描结果: {scan_results}")


